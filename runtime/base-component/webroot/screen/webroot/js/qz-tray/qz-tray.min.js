/**
 * @version 2.0.7;
 * @overview QZ Tray Connector
 * <p/>
 * Connects a web client to the QZ Tray software.
 * Enables printing and device communication from javascript.
 *
 * @requires RSVP
 *     Provides Promises/A+ functionality for API calls.
 *     Can be overridden via <code>qz.api.setPromiseType</code> to remove dependency.
 * @requires Sha256
 *     Provides hashing algorithm for signing messages.
 *     Can be overridden via <code>qz.api.setSha256Type</code> to remove dependency.
 */
var qz=function(){function g(a,c){this.setPrinter=function(a){"string"===typeof a&&(a={name:a});this.printer=a};this.getPrinter=function(){return this.printer};this.reconfigure=function(a){b.tools.extend(this.config,a)};this.getOptions=function(){return this.config};this.setPrinter(a);this.config=c}Array.isArray||(Array.isArray=function(a){return"[object Array]"===Object.prototype.toString.call(a)});var b={VERSION:"2.0.7",DEBUG:!1,log:{trace:function(){b.DEBUG&&console.log.apply(console,arguments)},
info:function(){console.info.apply(console,arguments)},warn:function(){b.DEBUG&&console.warn.apply(console,arguments)},error:function(){console.error.apply(console,arguments)}},streams:{serial:"SERIAL",usb:"USB",hid:"HID"},websocket:{connection:null,connectConfig:{host:["localhost","localhost.qz.io"],hostIndex:0,usingSecure:!0,protocol:{secure:"wss://",insecure:"ws://"},port:{secure:[8181,8282,8383,8484],insecure:[8182,8283,8384,8485],portIndex:0},keepAlive:60,retries:0,delay:0},setup:{findConnection:function(a,
c,d){if(a.port.secure.length)a.port.insecure.length||a.usingSecure||(b.log.trace("No insecure ports specified - forcing secure connection"),a.usingSecure=!0);else{if(!a.port.insecure.length){d(Error("No ports have been specified to connect over"));return}a.usingSecure&&(b.log.error("No secure ports specified - forcing insecure connection"),a.usingSecure=!1)}var f=function(){a.port.portIndex++;if(a.usingSecure&&a.port.portIndex>=a.port.secure.length||!a.usingSecure&&a.port.portIndex>=a.port.insecure.length){if(a.hostIndex>=
a.host.length-1){d(Error("Unable to establish connection with QZ"));return}a.hostIndex++;a.port.portIndex=0}b.websocket.setup.findConnection(a,c,d)},e;e=a.usingSecure?a.protocol.secure+a.host[a.hostIndex]+":"+a.port.secure[a.port.portIndex]:a.protocol.insecure+a.host[a.hostIndex]+":"+a.port.insecure[a.port.portIndex];try{b.log.trace("Attempting connection",e),b.websocket.connection=new b.tools.ws(e)}catch(k){b.log.error(k);f();return}null!=b.websocket.connection?(b.websocket.connection.established=
!1,b.websocket.connection.onopen=function(f){b.log.trace(f);b.log.info("Established connection with QZ Tray on "+e);b.websocket.setup.openConnection({resolve:c,reject:d});if(0<a.keepAlive)var g=setInterval(function(){qz.websocket.isActive()?b.websocket.connection.send("ping"):clearInterval(g)},1E3*a.keepAlive)},b.websocket.connection.onclose=function(){if("undefined"!==typeof navigator&&-1!=navigator.userAgent.indexOf("Safari")&&-1==navigator.userAgent.indexOf("Chrome"))b.websocket.connection.onerror()},
b.websocket.connection.onerror=function(a){b.log.trace(a);b.websocket.connection=null;f()}):d(Error("Unable to create a websocket connection"))},openConnection:function(a){function c(d){void 0===d&&(d=null);b.websocket.connection.sendData({certificate:d,promise:a})}b.websocket.connection.established=!0;b.websocket.connection.onclose=function(a){b.log.trace(a);b.log.info("Closed connection with QZ Tray");void 0!=b.websocket.connection.promise&&b.websocket.connection.promise.resolve();b.websocket.callClose(a);
b.websocket.connection=null;for(var c in b.websocket.pendingCalls)b.websocket.pendingCalls.hasOwnProperty(c)&&b.websocket.pendingCalls[c].reject(Error("Connection closed before response received"))};b.websocket.connection.onerror=function(a){b.websocket.callError(a)};b.websocket.connection.sendData=function(a){b.log.trace("Preparing object for websocket",a);void 0==a.timestamp&&(a.timestamp=Date.now(),"number"!==typeof a.timestamp&&(a.timestamp=(new Date).getTime()));void 0!=a.promise&&(a.uid=b.websocket.setup.newUID(),
b.websocket.pendingCalls[a.uid]=a.promise);a.position={x:screen?(screen.availWidth||screen.width)/2+(screen.left||screen.availLeft):0,y:screen?(screen.availHeight||screen.height)/2+(screen.top||screen.availTop):0};try{if(void 0!=a.call&&void 0==a.signature){var c=b.tools.hash(b.tools.stringify({call:a.call,params:a.params,timestamp:a.timestamp}));c.then||(c=b.tools.promise(function(a){a(c)}));c.then(function(a){return b.security.callSign(a)}).then(function(c){b.log.trace("Signature for call",c);a.signature=
c;b.signContent=void 0;b.websocket.connection.send(b.tools.stringify(a))})}else b.log.trace("Signature for call",a.signature),b.websocket.connection.send(b.tools.stringify(a))}catch(e){b.log.error(e),void 0!=a.promise&&(a.promise.reject(e),delete b.websocket.pendingCalls[a.uid])}};b.websocket.connection.onmessage=function(a){a=JSON.parse(a.data);if(null==a.uid)if(null==a.type)b.websocket.connection.close(4003,"Connected to incompatible QZ Tray version");else switch(a.type){case b.streams.serial:a.event||
(a.event=JSON.stringify({portName:a.key,output:a.data}));b.serial.callSerial(JSON.parse(a.event));break;case b.streams.usb:a.event||(a.event=JSON.stringify({vendorId:a.key[0],productId:a.key[1],output:a.data}));b.usb.callUsb(JSON.parse(a.event));break;case b.streams.hid:b.hid.callHid(JSON.parse(a.event));break;default:b.log.warn("Cannot determine stream type for callback",a)}else{b.log.trace("Received response from websocket",a);var c=b.websocket.pendingCalls[a.uid];void 0==c?b.log.warn("No promise found for returned response"):
void 0!=a.error?c.reject(Error(a.error)):c.resolve(a.result);delete b.websocket.pendingCalls[a.uid]}};b.security.callCert().then(c)["catch"](c)},newUID:function(){return(Array(7).join("0")+(Math.random()*Math.pow(36,6)<<0).toString(36)).slice(-6)}},dataPromise:function(a,c,d,f){return b.tools.promise(function(e,g){b.websocket.connection.sendData({call:a,promise:{resolve:e,reject:g},params:c,signature:d,timestamp:f})})},pendingCalls:{},errorCallbacks:[],callError:function(a){if(Array.isArray(b.websocket.errorCallbacks))for(var c=
0;c<b.websocket.errorCallbacks.length;c++)b.websocket.errorCallbacks[c](a);else b.websocket.errorCallbacks(a)},closedCallbacks:[],callClose:function(a){if(Array.isArray(b.websocket.closedCallbacks))for(var c=0;c<b.websocket.closedCallbacks.length;c++)b.websocket.closedCallbacks[c](a);else b.websocket.closedCallbacks(a)}},printing:{defaultConfig:{colorType:"color",copies:1,density:0,duplex:!1,fallbackDensity:null,interpolation:"bicubic",jobName:null,legacy:!1,margins:0,orientation:null,paperThickness:null,
printerTray:null,rasterize:!0,rotation:0,scaleContent:!0,size:null,units:"in",altPrinting:!1,encoding:null,endOfDoc:null,perSpool:1}},serial:{serialCallbacks:[],callSerial:function(a){if(Array.isArray(b.serial.serialCallbacks))for(var c=0;c<b.serial.serialCallbacks.length;c++)b.serial.serialCallbacks[c](a);else b.serial.serialCallbacks(a)}},usb:{usbCallbacks:[],callUsb:function(a){if(Array.isArray(b.usb.usbCallbacks))for(var c=0;c<b.usb.usbCallbacks.length;c++)b.usb.usbCallbacks[c](a);else b.usb.usbCallbacks(a)}},
hid:{hidCallbacks:[],callHid:function(a){if(Array.isArray(b.hid.hidCallbacks))for(var c=0;c<b.hid.hidCallbacks.length;c++)b.hid.hidCallbacks[c](a);else b.hid.hidCallbacks(a)}},security:{certPromise:function(a,b){b()},callCert:function(){return b.tools.promise(b.security.certPromise)},signaturePromise:function(){return function(a){a()}},callSign:function(a){return b.tools.promise(b.security.signaturePromise(a))}},tools:{promise:function(a){return new RSVP.Promise(a)},stringify:function(a){var b=Array.prototype.toJSON;
delete Array.prototype.toJSON;a=JSON.stringify(a);b&&(Array.prototype.toJSON=b);return a},hash:function(a){return Sha256.hash(a)},ws:"undefined"!==typeof WebSocket?WebSocket:null,absolute:function(a){if("undefined"!==typeof window&&"function"===typeof document.createElement){var b=document.createElement("a");b.href=a;return b.href}return a},extend:function(a){"object"!==typeof a&&(a={});for(var c=1;c<arguments.length;c++){var d=arguments[c];if(d)for(var f in d)if(d.hasOwnProperty(f)&&a!==d[f])if(d[f]&&
d[f].constructor&&d[f].constructor===Object){var e;e=Array.isArray(d[f])?a[f]||[]:a[f]||{};a[f]=b.tools.extend(e,d[f])}else void 0!==d[f]&&(a[f]=d[f])}return a}}};g.prototype.print=function(a,b,d){qz.print(this,a,b,d)};return{websocket:{isActive:function(){return null!=b.websocket.connection&&b.websocket.connection.established},connect:function(a){return b.tools.promise(function(c,d){if(qz.websocket.isActive())d(Error("An open connection with QZ Tray already exists"));else if(null!=b.websocket.connection)d(Error("The current connection attempt has not returned yet"));
else if(b.tools.ws)if(b.tools.ws.CLOSED&&2!=b.tools.ws.CLOSED){void 0==a&&(a={});"undefined"!==typeof location&&"https:"===location.protocol||"undefined"!==typeof a.usingSecure||(b.log.trace("Disabling secure ports due to insecure page"),a.usingSecure=!1);"undefined"===typeof a.host||Array.isArray(a.host)||(a.host=[a.host]);var f=function(e){var g=function(){a&&e<a.retries?f(e+1):d.apply(null,arguments)},h=function(){var d=b.tools.extend({},b.websocket.connectConfig,a);b.websocket.setup.findConnection(d,
c,g)};0==e?h():setTimeout(h,1E3*a.delay)};f(0)}else d(Error("Unsupported WebSocket version detected: HyBi-00/Hixie-76"));else d(Error("WebSocket not supported by this browser"))})},disconnect:function(){return b.tools.promise(function(a,c){qz.websocket.isActive()?(b.websocket.connection.close(),b.websocket.connection.promise={resolve:a,reject:c}):c(Error("No open connection with QZ Tray"))})},setErrorCallbacks:function(a){b.websocket.errorCallbacks=a},setClosedCallbacks:function(a){b.websocket.closedCallbacks=
a},getNetworkInfo:function(a,c){return b.websocket.dataPromise("websocket.getNetworkInfo",{hostname:a,port:c})},getConnectionInfo:function(){if(b.websocket.connection){var a=b.websocket.connection.url.split(/[:\/]+/g);return{socket:a[0],host:a[1],port:+a[2]}}throw Error("A connection to QZ has not been established yet");}},printers:{getDefault:function(){return b.websocket.dataPromise("printers.getDefault")},find:function(a){return b.websocket.dataPromise("printers.find",{query:a})}},configs:{setDefaults:function(a){b.tools.extend(b.printing.defaultConfig,
a)},create:function(a,c){var d=b.tools.extend({},b.printing.defaultConfig,c);return new g(a,d)}},print:function(a,c,d,f){for(var e=0;e<c.length;e++)if(c[e].constructor===Object){if(!c[e].format&&c[e].type&&"RAW"!==c[e].type.toUpperCase()&&"DIRECT"!==c[e].type.toUpperCase()||c[e].format&&("FILE"===c[e].format.toUpperCase()||"IMAGE"===c[e].format.toUpperCase()&&(0!==c[e].data.indexOf("data:image/")||0===c[e].data.indexOf(";base64,"))||"XML"===c[e].format.toUpperCase()))c[e].data=b.tools.absolute(c[e].data);
c[e].options&&"string"===typeof c[e].options.overlay&&(c[e].options.overlay=b.tools.absolute(c[e].options.overlay))}a={printer:a.getPrinter(),options:a.getOptions(),data:c};return b.websocket.dataPromise("print",a,d,f)},serial:{findPorts:function(){return b.websocket.dataPromise("serial.findPorts")},setSerialCallbacks:function(a){b.serial.serialCallbacks=a},openPort:function(a,c){return b.websocket.dataPromise("serial.openPort",{port:a,options:c})},sendData:function(a,c,d){null!=d&&b.log.warn("Properties object is deprecated on sendData calls, use openPort instead.");
return b.websocket.dataPromise("serial.sendData",{port:a,data:c,properties:d})},closePort:function(a){return b.websocket.dataPromise("serial.closePort",{port:a})}},usb:{listDevices:function(a){return b.websocket.dataPromise("usb.listDevices",{includeHubs:a})},listInterfaces:function(a,c){"object"!==typeof a&&(a={vendorId:a,productId:c});return b.websocket.dataPromise("usb.listInterfaces",a)},listEndpoints:function(a,c,d){"object"!==typeof a&&(a={vendorId:a,productId:c,"interface":d});return b.websocket.dataPromise("usb.listEndpoints",
a)},setUsbCallbacks:function(a){b.usb.usbCallbacks=a},claimDevice:function(a,c,d){"object"!==typeof a&&(a={vendorId:a,productId:c,"interface":d});return b.websocket.dataPromise("usb.claimDevice",a)},isClaimed:function(a,c){"object"!==typeof a&&(a={vendorId:a,productId:c});return b.websocket.dataPromise("usb.isClaimed",a)},sendData:function(a,c,d,f){"object"!==typeof a&&(a={vendorId:a,productId:c,endpoint:d,data:f});return b.websocket.dataPromise("usb.sendData",a)},readData:function(a,c,d,f){"object"!==
typeof a&&(a={vendorId:a,productId:c,endpoint:d,responseSize:f});return b.websocket.dataPromise("usb.readData",a)},openStream:function(a,c,d,f,e){"object"!==typeof a&&(a={vendorId:a,productId:c,endpoint:d,responseSize:f,interval:e});return b.websocket.dataPromise("usb.openStream",a)},closeStream:function(a,c,d){"object"!==typeof a&&(a={vendorId:a,productId:c,endpoint:d});return b.websocket.dataPromise("usb.closeStream",a)},releaseDevice:function(a,c){"object"!==typeof a&&(a={vendorId:a,productId:c});
return b.websocket.dataPromise("usb.releaseDevice",a)}},hid:{listDevices:function(){return b.websocket.dataPromise("hid.listDevices")},startListening:function(){return b.websocket.dataPromise("hid.startListening")},stopListening:function(){return b.websocket.dataPromise("hid.stopListening")},setHidCallbacks:function(a){b.hid.hidCallbacks=a},claimDevice:function(a,c){"object"!==typeof a&&(a={vendorId:a,productId:c});return b.websocket.dataPromise("hid.claimDevice",a)},isClaimed:function(a,c){"object"!==
typeof a&&(a={vendorId:a,productId:c});return b.websocket.dataPromise("hid.isClaimed",a)},sendData:function(a,c,d,f){"object"!==typeof a&&(a={vendorId:a,productId:c,data:d,endpoint:f});return b.websocket.dataPromise("hid.sendData",a)},readData:function(a,c,d){"object"!==typeof a&&(a={vendorId:a,productId:c,responseSize:d});return b.websocket.dataPromise("hid.readData",a)},openStream:function(a,c,d,f){"object"!==typeof a&&(a={vendorId:a,productId:c,responseSize:d,interval:f});return b.websocket.dataPromise("hid.openStream",
a)},closeStream:function(a,c){"object"!==typeof a&&(a={vendorId:a,productId:c});return b.websocket.dataPromise("hid.closeStream",a)},releaseDevice:function(a,c){"object"!==typeof a&&(a={vendorId:a,productId:c});return b.websocket.dataPromise("hid.releaseDevice",a)}},security:{setCertificatePromise:function(a){b.security.certPromise=a},setSignaturePromise:function(a){b.security.signaturePromise=a}},api:{showDebug:function(a){b.DEBUG=a},getVersion:function(){return b.websocket.dataPromise("getVersion")},
setPromiseType:function(a){b.tools.promise=a},setSha256Type:function(a){b.tools.hash=a},setWebSocketType:function(a){b.tools.ws=a}},version:b.VERSION}}();(function(){if("function"===typeof define&&define.amd)define(qz);else if("object"===typeof exports){module.exports=qz;try{var g=require("crypto");qz.api.setSha256Type(function(b){return g.createHash("sha256").update(b).digest("hex")})}catch(b){}}else window.qz=qz})();
