<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
    <xs:include schemaLocation="common-types-2.0.xsd"/>
    <xs:include schemaLocation="xml-actions-2.0.xsd"/>
    <xs:include schemaLocation="xml-form-2.0.xsd"/>

    <!-- ================ Shared Elements ================ -->
    <xs:group name="section-elements">
        <xs:sequence>
            <xs:element ref="condition" minOccurs="0"/>
            <xs:element ref="actions" minOccurs="0"/>
            <xs:element ref="widgets"/>
            <xs:element ref="fail-widgets" minOccurs="0"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="widget-elements">
        <xs:choice>
            <xs:element ref="AllWidgets"/>
            <xs:element ref="StandaloneFields"/>
            <!-- allow additional elements without validation to facilitate extension by adding only FTL macros -->
            <xs:any minOccurs="0" maxOccurs="unbounded" processContents="skip"/>
        </xs:choice>
    </xs:group>

    <!-- ================ Screen - root element ================ -->
    <xs:element name="screen">
        <xs:annotation><xs:documentation>
            The screen is the basic unit of a user interface defines how data, logic, and visual elements fit together.

            Screen filenames should be camel-cased and start with an upper-case letter (whereas transitions should
            start with a lower-case letter).
        </xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="macro-template" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="web-settings" minOccurs="0"/>
                <xs:element ref="parameter" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation><xs:documentation>
                        These are the parameters the screen expects or allows to be passed in, and where the calling
                        screen can get them from by default (usually just default to the same from, but can be a
                        static value for default or whatever).

                        Individual transition, transition.*-response and other elements can override where the parameter
                        comes from with their own parameter sub-elements.
                    </xs:documentation></xs:annotation>
                </xs:element>
                <xs:element ref="always-actions" minOccurs="0"/>
                <xs:choice minOccurs="0" maxOccurs="unbounded">
                    <xs:element ref="transition"/>
                    <xs:element ref="transition-include"/>
                </xs:choice>
                <xs:element ref="subscreens" minOccurs="0"/>
                <xs:element ref="pre-actions" minOccurs="0"/>
                <xs:group ref="section-elements"/>
            </xs:sequence>
            <xs:attribute name="standalone" type="boolean" default="false">
                <xs:annotation><xs:documentation>
                    If set to true this screen will be rendered without rendering any parent screens. It can still be
                    referred to as a subscreen of its parent, but when rendered the parent will not run, the rendering
                    will start at this screen. Any non-standalone children will still be treated as normal subscreens.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="default-menu-title" type="xs:string"/>
            <xs:attribute name="default-menu-index" type="xs:nonNegativeInteger"/>
            <xs:attribute name="default-menu-include" type="boolean" default="true">
                <xs:annotation><xs:documentation>
                    Set this to false to not automatically appear in the parent's subscreens menu based on the directory 
                    it is in. If true this screen will automatically be included in the parent's subscreens menu.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="menu-image" type="xs:string"/>
            <xs:attribute name="menu-image-type" default="url-screen">
                <xs:simpleType>
                    <xs:restriction base="xs:token">
                        <xs:enumeration value="url-screen"/>
                        <xs:enumeration value="url-plain"/>
                        <xs:enumeration value="icon"><xs:annotation><xs:documentation>Icon name, actually an icon
                            style used in an 'i' element in HTML output.</xs:documentation></xs:annotation></xs:enumeration>
                    </xs:restriction>
                </xs:simpleType>
            </xs:attribute>

            <xs:attribute name="require-authentication" type="authc-options" default="true"/>
            <!-- TABLED, not to be part of 1.0: <xs:attribute name="require-certificate" default="false" type="boolean"/> -->
            <xs:attribute name="begin-transaction" type="boolean" default="false">
                <xs:annotation><xs:documentation>
                    Begin a transaction for the screen render if there is not one already in place.
                    Most screens don't need this, but it is useful for greater data consistency in certain cases.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="include-child-content" type="boolean" default="false">
                <xs:annotation><xs:documentation>
                    False by default, meaning that child content is sent to the client as they are and nothing else with
                    it. If true then the child content is included in this screen as if it were a subscreen.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="screen-theme-type-enum-id" type="xs:string" default="STT_INTERNAL"/>
            <xs:attribute name="track-artifact-hit" type="boolean" default="true">
                <xs:annotation><xs:documentation>If set to false no ArtifactHit or ArtifactHitBin data will be kept for
                    this screen and for any content or transitions under the screen.</xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="login-path" type="xs:string" default="/Login">
                <xs:annotation><xs:documentation>If specified will be used as the login screen path for this screen and
                    any subscreens, otherwise defaults to "/Login".</xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="allow-extra-path" type="boolean" default="false">
                <xs:annotation><xs:documentation>If set to true arbitrary path follow this screen's path is allowed.
                    Default is false and an exception will be thrown if there is extra path that does not match a
                    subscreen, a transition, or content below the screen.</xs:documentation></xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="macro-template">
        <xs:annotation><xs:documentation>
            A location here will override the settings in the moqui-conf.screen-facade.screen-text-output, but will be
            overridden by a value set with the ScreenRender.macroTemplate() method.
        </xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:attribute name="type" type="xs:string" use="required">
                <xs:annotation><xs:documentation>
                    Can be anything. Default supported values include: text, html, xsl-fo, xml, and csv.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="location" type="xs:string" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="web-settings">
        <xs:complexType>
            <xs:attribute name="allow-web-request" default="true" type="boolean"/>
            <xs:attribute name="require-encryption" default="true" type="boolean"/>
            <xs:attribute name="mime-type" type="xs:string" default="text/html"/>
            <xs:attribute name="character-encoding" type="xs:string" default="UTF-8"/>
            <!-- TABLED, not to be part of 1.0: <xs:attribute name="http-no-cache" default="false" type="boolean"/> -->
            <!-- NOTE: Right now we send some cache headers, could add config for cache headers for screen,
                 static screen content, template screen content -->
        </xs:complexType>
    </xs:element>
    <xs:element name="always-actions">
        <xs:annotation><xs:documentation>These actions always run when this screen appears in a screen path, including
            both screen rendering and transition running. One difference between this and the pre-actions element is
            that this runs before transitions are processed while pre-actions do not. The always-actions also run for
            all screens in a path while the pre-actions only run for screens that will be rendered.</xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:group minOccurs="0" maxOccurs="unbounded" ref="AllOperations"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="pre-actions">
        <xs:annotation><xs:documentation>These actions run before any of the screens (this screen or any parent screens)
            are rendered, allowing you to set parameters used by parent screens or other general reasons.</xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:group minOccurs="0" maxOccurs="unbounded" ref="AllOperations"/>
        </xs:complexType>
    </xs:element>


    <!-- ================ Transition ================ -->
    <xs:element name="transition">
        <xs:annotation><xs:documentation>
        </xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="parameter" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation><xs:documentation>
                        These are the parameters the transition expects or allows to be passed in, and where the calling
                        screen can get them from by default (usually just default to the same from, but can be a
                        static value for default or whatever).

                        These are in addition to the screen.parameter values. Individual transition.*-response and other
                        elements can override where the parameter comes from with their own parameter sub-elements.
                    </xs:documentation></xs:annotation>
                </xs:element>
                <xs:element ref="path-parameter" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation><xs:documentation>
                        These are additional path elements after the transition's path element. The values will be added
                        to the web parameters based on the order of these path-elements.
                    </xs:documentation></xs:annotation>
                </xs:element>
                <xs:element ref="condition" minOccurs="0">
                    <xs:annotation><xs:documentation>
                        This condition is run wherever this transition is referenced in the screen to see if the
                        transition is available (otherwise the button/link/etc is disabled).
                    </xs:documentation></xs:annotation>
                </xs:element>
                <xs:choice minOccurs="0">
                    <xs:element ref="service-call">
                        <xs:annotation><xs:documentation>
                            In most cases the best way to handle input for a transition is with a single service. To do
                            that use this element instead of an actions element.

                            This will automatically have an in-map=true. To get the same effect inside the actions
                            element just use in-map=true.
                        </xs:documentation></xs:annotation>
                    </xs:element>
                    <xs:element ref="actions">
                        <xs:annotation><xs:documentation>
                            When this transition is followed these actions are run.

                            After the actions are run it goes to the url that this transition goes to (through
                            client-side redirect, dynamic update of a screen area, etc).
                        </xs:documentation></xs:annotation>
                    </xs:element>
                </xs:choice>
                <xs:element ref="conditional-response" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation><xs:documentation>
                        If there are multiple transition-response sub-elements the first one whose condition evaluates
                        to true will be the one used. If no conditional responses match, the default-response will be
                        used.
                    </xs:documentation></xs:annotation>
                </xs:element>
                <xs:element ref="default-response">
                    <xs:annotation><xs:documentation>
                        This response must always be defined and is the response that will be used if there is no error
                        in the actions, and if none of the conditions in conditional responses evaluate to true.
                    </xs:documentation></xs:annotation>
                </xs:element>
                <xs:element ref="error-response" minOccurs="0">
                    <xs:annotation><xs:documentation>
                        If there is an error in evaluating the actions on this transition then the error-response will
                        be used and the transition-response element(s) will be ignored.

                        If there are actions and there is no error-response defined then the default error response
                        will be used.
                    </xs:documentation></xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attribute name="name" type="name-package" use="required">
                <xs:annotation><xs:documentation>
                    Transition names should be camel-cased and start with an lower-case letter (whereas screen filenames
                    and subscreens-item names start with a upper-case letter).

                    The transition name is used in link and other elements in place of URLs when going to another
                    screen within this application. The transition name will appear briefly as the URL before the
                    redirect is done for the transition response.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="method" default="any">
                <xs:simpleType>
                    <xs:restriction base="xs:token">
                        <xs:enumeration value="any"/>
                        <xs:enumeration value="get"/>
                        <xs:enumeration value="put"/>
                        <xs:enumeration value="post"/>
                        <xs:enumeration value="delete"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="begin-transaction" type="boolean" default="true">
                <xs:annotation><xs:documentation>Begin a transaction for the screen transition action run if there is
                    not one already in place.</xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="read-only" type="boolean" default="false">
                <xs:annotation><xs:documentation>Declare that this transition does only read operations to skip the
                    check for insecure parameters.</xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="require-session-token" default="true" type="boolean"><xs:annotation><xs:documentation>
                If not false (default true) moquiSessionToken (from ec.web.sessionToken) must be passed to this
                transition for all requests in a session after the first.</xs:documentation></xs:annotation></xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="path-parameter">
        <xs:complexType>
            <xs:attribute name="name" type="name-parameter" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="conditional-response">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="condition" minOccurs="0"/>
                <xs:element ref="parameter" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation><xs:documentation>
                        These parameters will be used when redirecting to the url or other activating of the target
                        screen.

                        Each screen has a list of expected parameters so this is only necessary when you need to
                        override where the parameter value comes from (default defined in the parameter tag under the
                        screen) or to pass additional parameters.
                    </xs:documentation></xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.response"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="default-response">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="parameter" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation><xs:documentation>
                        These parameters will be used when redirecting to the url or other activating of the target
                        screen.

                        Each screen has a list of expected parameters so this is only necessary when you need to
                        override where the parameter value comes from (default defined in the parameter tag under the
                        screen) or to pass additional parameters.
                    </xs:documentation></xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.response"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="error-response">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="parameter" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation><xs:documentation>
                        These parameters will be used when redirecting to the url or other activating of the target
                        screen.

                        Each screen has a list of expected parameters so this is only necessary when you need to
                        override where the parameter value comes from (default defined in the parameter tag under the
                        screen) or to pass additional parameters.
                    </xs:documentation></xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.response"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.response">
        <xs:attribute name="type" default="url">
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="none"/>
                    <xs:enumeration value="screen-last">
                        <xs:annotation><xs:documentation>
                            Go to the screen from the last request (via screen history) unless there is a saved one
                            from some previous request (using the save-current-screen attribute, done automatically for
                            login). If neither available will go to the default screen (just to root with whatever
                            defaults are setup for each subscreen).
                        </xs:documentation></xs:annotation>
                    </xs:enumeration>
                    <xs:enumeration value="screen-last-noparam"/>
                    <xs:enumeration value="url"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="url" type="xs:string">
            <xs:annotation><xs:documentation>
                The URL to follow in response, based on the url-type. The default url-type is "screen-path" which means
                the value here is a path from the current screen to the desired screen, transition, or sub-screen content.

                Use "." to represent the current screen, and ".." to represent the parent screen on the runtime
                screen path. The ".." can be used multiple times, such as "../.." to get to the parent screen of the
                parent screen (the grand-parent screen).

                If the screen-path type url starts with a "/" it will be relative to the root screen instead of relative
                to the current screen. If it starts with a "//" it will be relative to the root screen and a sparse
                path, meaning that each path item specified will be searched for under the previous and does not have
                to be a direct subscreen.

                If the url-type is "plain" then this can be any valid URL (relative on current domain or absolute).
            </xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute name="url-type" default="screen-path">
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="screen-path">
                        <xs:annotation><xs:documentation>URI to another screen, either relative or from server root.
                            See documentation on url attribute for more details.</xs:documentation></xs:annotation>
                    </xs:enumeration>
                    <xs:enumeration value="plain"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="parameter-map" type="xs:string">
            <xs:annotation><xs:documentation>Just like the parameter subelement can be used to specify parameters to
                pass with the redirect.</xs:documentation></xs:annotation>
        </xs:attribute>
        <!-- deferred for future version, pending finding a good reason that it is needed:
        <xs:attribute name="save-last-screen" default="false" type="boolean">
            <xs:annotation><xs:documentation>
                Saves the last (previous) screen's path and parameters for future use, generally with the screen-last type of
                response.
            </xs:documentation></xs:annotation>
        </xs:attribute> -->
        <xs:attribute name="save-current-screen" default="false" type="boolean">
            <xs:annotation><xs:documentation>Save the current screen's path and parameters for future use, generally
                with the screen-last type of response.</xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute name="save-parameters" default="false" type="boolean">
            <xs:annotation><xs:documentation>Save the current parameters (and request attributes) before doing a
                redirect so that the screen rendered after the redirect renders in a context similar to the original
                request to the transition.</xs:documentation></xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>

    <xs:element name="transition-include">
        <xs:complexType>
            <xs:attribute name="name" type="name-package" use="required"/>
            <xs:attribute name="location" type="xs:string" use="required"/>
            <xs:attribute name="method" type="xs:string"/>
        </xs:complexType>
    </xs:element>

    <!-- ================ Subscreens ================ -->
    <xs:element name="subscreens">
        <xs:annotation><xs:documentation>
            Declare subscreens for this screen. One subscreen at a time is active, based on the "screen path" used to
            access this screen. The parent screen (this screen) will be the current element in the screen path and the
            next screen path element will be the name of the subscreen of this screen to use.

            If there is no additional element in the screen path or the next element is not a valid subscreen-item.name
            then the default-item will be the active subscreen. 

            There are three ways to add subscreens to a screen:

            1. for screens within a single application:
               by directory structure: create a directory in the directory where the parent screen is named the same as
               the parent screen's filename and put XML Screen files in that directory (name=filename up to .xml,
               title=screen.default-title, location=parent screen minus filename plus directory and filename for
               subscreen)
            2. for including screens that are part of another application, or shared and not in any application:
               subscreens-item elements below the screen -> subscreens element (this element)
            3. for adding screens, removing screens, or changing order and title of screens to an existing application:
               a record in the moqui.screen.SubscreensItem entity

            There are two visual elements (widgets) that come from the subscreens, a menu and the active subscreen.
            Those are included with the widgets using the "subscreens-menu" and "subscreens-active" elements, or the
            "subscreens-panel" element.
        </xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="conditional-default" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="subscreens-item" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="default-item" type="xs:string">
                <xs:annotation><xs:documentation>
                    The name of the default subscreen-item. Used when then screen-path ends on this screen so we
                    know which subscreen-item to activate.

                    If empty the first subscreen-item will be the default.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="always-use-full-path" type="boolean" default="false"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="conditional-default">
        <xs:complexType>
            <xs:attribute name="condition" type="xs:string" use="required">
                <xs:annotation><xs:documentation>Groovy condition expression (evaluates to a boolean) used to determine
                    if the specified subscreens item is the one to use by default instead of the on specified in the
                    subscreens.@default-item attribute.</xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="item" type="xs:string" use="required">
                <xs:annotation><xs:documentation>The subscreens item to make the default.</xs:documentation></xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="subscreens-item">
        <xs:annotation><xs:documentation>
            One way to add a subscreen. This is most commonly used to refer to a subscreen that is located in another
            application, another part of this application, that is not in any application and is meant to be shared,
            or is in a different type of location than the parent screen.

            One subscreens-item is active at a time, meaning that screen is shown and the tab/etc for that screen is
            highlighted.
        </xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:attribute name="name" type="name-plain" use="required">
                <xs:annotation><xs:documentation>
                    The name of the subscreens item for use in the screen path. The screen path element following the
                    one for the parent screen of the item will match on this name.

                    Subscreen Item names should be camel-cased and start with a upper-case letter (just like screen
                    filenames start with a upper-case letter).
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="location" type="xs:string">
                <xs:annotation><xs:documentation>
                    Subscreen location can include various prefixes to support including from a file, http, component,
                    or a content repository.

                    If empty defaults to the value of the name attribute under the current screen (in the directory
                    with the same name as the current screen), and can be a screen or sub-content.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="menu-title" type="xs:string"/>
            <xs:attribute name="menu-index" type="xs:positiveInteger">
                <xs:annotation><xs:documentation>
                    If specified this item will be inserted in existing list of subscreens at this index (1-based).
                    If empty this item will be added to the end of the list (after the directory load, before the
                    entity load).
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="menu-include" type="boolean" default="true"/>
            <xs:attribute name="disable-when" type="xs:positiveInteger">
                <xs:annotation><xs:documentation>This condition is run the subscreens menu is rendered to see if the
                    item is available (otherwise the button/link/etc is disabled).</xs:documentation></xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="subscreens-menu" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:attribute name="type" default="tab">
                <xs:simpleType><xs:restriction base="xs:token">
                    <xs:enumeration value="tab"/>
                    <xs:enumeration value="popup"/>
                </xs:restriction></xs:simpleType>
            </xs:attribute>
            <xs:attribute name="id" type="xs:string" use="required"/>
            <xs:attribute name="title" type="xs:string"/>
            <xs:attribute name="width" type="xs:string"/>
            <xs:attribute name="header-menus-id" type="xs:string" default="header-menus"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="subscreens-active" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:attribute name="id" type="xs:string" use="optional"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="subscreens-panel" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:attribute name="type" default="tab">
                <xs:simpleType><xs:restriction base="xs:token">
                    <xs:enumeration value="tab"/>
                    <xs:enumeration value="popup"/>
                    <!-- TABLED, not to be part of 1.0: <xs:enumeration value="stack"/> -->
                    <!-- TABLED, not to be part of 1.0: <xs:enumeration value="wizard"/> -->
                </xs:restriction></xs:simpleType>
            </xs:attribute>
            <xs:attribute name="id" type="xs:string" use="required"/>
            <xs:attribute name="title" type="xs:string"/>
            <xs:attribute name="menu-width" type="xs:string"/>
            <xs:attribute name="dynamic" type="boolean" default="false"/>
            <xs:attribute name="header-menus-id" type="xs:string" default="header-menus"/>
        </xs:complexType>
    </xs:element>

    <!-- ================ Sections ================ -->
    <xs:element name="section" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:group ref="section-elements"/>
            <xs:attribute name="name" type="name-plain" use="required">
                <xs:annotation><xs:documentation>A name for the section, used for reference within the screen.
                    Must be specified and must be unique within the screen.</xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="condition" type="xs:string">
                <xs:annotation><xs:documentation>A condition expression, just like the section.condition.expression
                    element but more concise.</xs:documentation></xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="section-iterate" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:group ref="section-elements"/>
            <xs:attribute name="name" type="name-plain" use="required">
                <xs:annotation><xs:documentation>
                    A name for the section, used for external reference within the screen.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="list" type="xs:string" use="required">
                <xs:annotation><xs:documentation>
                    The name of the field that contains the list to iterate over.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="entry" type="xs:string" use="required">
                <xs:annotation><xs:documentation>
                    The name of the field that will contain each entry as we iterate through the list.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="key" type="xs:string">
                <xs:annotation><xs:documentation>
                    If list points to a Map or List of MapEntry the key will be put where this refers to, the value
                    where the entry attribute refers to.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="condition" type="xs:string">
                <xs:annotation><xs:documentation>A condition expression, just like the section-iterate.condition.expression
                    element but more concise.</xs:documentation></xs:annotation>
            </xs:attribute>
            <!-- TODO handle paginate* in ScreenSection.groovy
            <xs:attribute name="paginate" type="xs:string" default="false">
                <xs:annotation><xs:documentation>
                    Indicate if this section is paginated or not, false by default.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="paginate-size" type="xs:string"/>
            -->
        </xs:complexType>
    </xs:element>

    <xs:element name="widgets">
        <xs:complexType>
            <xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="fail-widgets">
        <xs:complexType>
            <xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="section-include" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:attribute name="name" type="name-plain" use="required">
                <xs:annotation><xs:documentation>
                    A name for the section, used for reference within the screen.
                    Must be specified and must be unique within the screen.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="location" type="xs:string" use="required">
                <xs:annotation><xs:documentation>
                    Location of the screen containing the section to include.
                </xs:documentation></xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>

    <!-- ================ Containers ================ -->
    <xs:element name="container" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/>
            <xs:attribute name="id" type="xs:string"/>
            <xs:attribute name="style" type="xs:string"/>
            <xs:attribute name="type" default="div">
                <xs:simpleType>
                    <xs:restriction base="xs:token">
                        <xs:enumeration value="div"/>
                        <xs:enumeration value="span"/>
                        <xs:enumeration value="ul"/>
                        <xs:enumeration value="li"/>
                        <xs:enumeration value="header"/>
                        <xs:enumeration value="footer"/>
                        <xs:enumeration value="code"/>
                        <xs:enumeration value="pre"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:attribute>
        </xs:complexType>
    </xs:element>

    <xs:element name="container-box" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="box-header"/>
                <xs:element ref="box-toolbar" minOccurs="0"/>
                <xs:choice>
                    <xs:sequence>
                        <xs:element ref="box-body"/>
                        <xs:element ref="box-body-nopad" minOccurs="0"/>
                    </xs:sequence>
                    <xs:element ref="box-body-nopad"/>
                </xs:choice>
            </xs:sequence>
            <xs:attribute name="id" type="xs:string"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="box-header">
        <xs:complexType><xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/></xs:complexType></xs:element>
    <xs:element name="box-toolbar">
        <xs:complexType><xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/></xs:complexType></xs:element>
    <xs:element name="box-body">
        <xs:complexType><xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/></xs:complexType></xs:element>
    <xs:element name="box-body-nopad">
        <xs:complexType><xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/></xs:complexType></xs:element>

    <xs:element name="container-row" substitutionGroup="AllWidgets">
        <xs:annotation><xs:documentation>A responsive 12-column grid row. For the concept and one possible
            implementation see http://getbootstrap.com/css/#grid</xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:sequence><xs:element ref="row-col" maxOccurs="unbounded"/></xs:sequence>
            <xs:attribute name="id" type="xs:string"/>
            <xs:attribute name="style" type="xs:string"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="row-col">
        <xs:complexType>
            <xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/>
            <xs:attribute name="lg" type="xs:string"/>
            <xs:attribute name="md" type="xs:string"/>
            <xs:attribute name="sm" type="xs:string"/>
            <xs:attribute name="xs" type="xs:string"/>
            <xs:attribute name="style" type="xs:string"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="container-panel" substitutionGroup="AllWidgets">
        <xs:annotation><xs:documentation>
            This panel can have up to five areas: header, left, center, right, footer. Only the center area is required.
            This can be re-used within the different areas as well, usually just the center area but could be used to
            split up even the header and footer.

            If there is an id for the outer container, and each area will have an automatic id as well (with a suffix
            of: _header, _left, _center, _right, _footer).
        </xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="panel-header" minOccurs="0"/>
                <xs:element ref="panel-left" minOccurs="0"/>
                <xs:element ref="panel-center"/>
                <xs:element ref="panel-right" minOccurs="0"/>
                <xs:element ref="panel-footer" minOccurs="0"/>
            </xs:sequence>
            <xs:attribute name="id" type="xs:string"/>
            <xs:attribute name="dynamic" default="false" type="boolean"><xs:annotation><xs:documentation>
                When true uses a dynamic layout, by default with jQuery Layout (see http://layout.jquery-dev.net/).
                When false (default) uses a static HTML/CSS layout.
            </xs:documentation></xs:annotation></xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.panel.header-footer">
        <xs:attribute name="closable" default="true" type="boolean"/>
        <xs:attribute name="resizable" default="false" type="boolean"/>
        <xs:attribute name="spacing" type="xs:string" default="5"/>
        <xs:attribute name="size" type="xs:string" default="auto"/>
        <xs:attribute name="size-min" type="xs:float"/>
        <xs:attribute name="size-max" type="xs:float"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="attlist.panel.left-right">
        <xs:attribute name="closable" default="true" type="boolean"/>
        <xs:attribute name="resizable" default="true" type="boolean"/>
        <xs:attribute name="spacing" type="xs:string" default="5"/>
        <xs:attribute name="size" type="xs:string" default="180"/>
        <xs:attribute name="size-min" type="xs:float"/>
        <xs:attribute name="size-max" type="xs:float"/>
    </xs:attributeGroup>
    <xs:element name="panel-header">
        <xs:complexType>
            <xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/>
            <xs:attributeGroup ref="attlist.panel.header-footer"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="panel-left">
        <xs:complexType>
            <xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/>
            <xs:attributeGroup ref="attlist.panel.left-right"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="panel-center">
        <xs:complexType>
            <xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="panel-right">
        <xs:complexType>
            <xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/>
            <xs:attributeGroup ref="attlist.panel.left-right"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="panel-footer">
        <xs:complexType>
            <xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/>
            <xs:attributeGroup ref="attlist.panel.header-footer"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="container-dialog" substitutionGroup="AllWidgets">
        <xs:annotation><xs:documentation>The contents start out hidden with only a button with the button-text on it.
            When the button is clicked on a dialog opens to show the contents.</xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/>
            <xs:attribute name="id" type="xs:string" use="required"/>
            <xs:attribute name="button-text" type="xs:string" use="required"/>
            <xs:attribute name="width" type="xs:string" default="760"/>
            <xs:attribute name="height" type="xs:string" default="600"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="dynamic-dialog" substitutionGroup="StandaloneFields">
        <xs:annotation><xs:documentation>When the button is pressed the dialog contents are loaded from the server at
            the given transition.</xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:sequence><xs:element minOccurs="0" maxOccurs="unbounded" ref="parameter"/></xs:sequence>
            <xs:attribute name="id" type="xs:string" use="required"/>
            <xs:attribute name="button-text" type="xs:string" use="required"/>
            <xs:attribute name="width" type="xs:string" default="760"/>
            <xs:attribute name="height" type="xs:string" default="600"/>
            <xs:attribute name="transition" type="xs:string" use="required"/>
            <xs:attribute name="parameter-map" type="xs:string"><xs:annotation><xs:documentation>A Map to get parameter
                names and values from in addition to the parameter sub-elements.</xs:documentation></xs:annotation></xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="dynamic-container" substitutionGroup="StandaloneFields">
        <xs:annotation><xs:documentation>Container contents are immediately loaded from the server at the given
            transition. Contents may be reloaded based on other actions such as background form submissions.</xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:sequence><xs:element minOccurs="0" maxOccurs="unbounded" ref="parameter"/></xs:sequence>
            <xs:attribute name="id" type="xs:string" use="required"/>
            <xs:attribute name="transition" type="xs:string" use="required"/>
            <xs:attribute name="parameter-map" type="xs:string"><xs:annotation><xs:documentation>A Map to get parameter
                names and values from in addition to the parameter sub-elements.</xs:documentation></xs:annotation></xs:attribute>
        </xs:complexType>
    </xs:element>


    <!-- ================ Includes ================ -->
    <!-- possible good idea, but not implementing in 1.0; should use render-mode.text instead
    <xs:element name="include-content" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:attribute name="content-path" type="xs:string"/>
            <xs:attribute name="sub-content-key" type="xs:string" use="optional"/>
            <xs:attribute name="xml-escape" default="false" type="boolean"/>
        </xs:complexType>
    </xs:element>
    -->
    <xs:element name="include-screen" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:attribute name="location" type="xs:string" use="required"/>
            <xs:attribute name="share-scope" default="false" type="boolean"/>
        </xs:complexType>
    </xs:element>

    <!-- ============== Tree ============== -->
    <!-- Based on jstree, see http://www.jstree.com/docs/json/ -->
    <xs:element name="tree" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:sequence>
                <xs:element minOccurs="0" maxOccurs="unbounded" ref="parameter"><xs:annotation><xs:documentation>
                    The parameters are for remote request of sub-nodes for a node when lazy loading and are in the
                    context of the initial rendering of the tree in the screen.</xs:documentation></xs:annotation></xs:element>
                <xs:element maxOccurs="unbounded" ref="tree-node"/>
                <xs:element maxOccurs="unbounded" ref="tree-sub-node"/>
            </xs:sequence>
            <xs:attribute type="xs:string" name="name" use="required"/>
            <xs:attribute type="xs:string" name="transition" default="getTreeSubNodes"/>
            <xs:attribute type="xs:string" name="open-path" use="optional"/>
            <!-- <xs:attribute type="xs:string" name="open-depth" default="0"/> -->
        </xs:complexType>
    </xs:element>
    <xs:element name="tree-node">
        <xs:complexType>
            <xs:sequence>
                <xs:element minOccurs="0" ref="condition"/>
                <xs:element minOccurs="0" ref="actions"/>
                <xs:element ref="link"/>
                <xs:element minOccurs="0" maxOccurs="unbounded" ref="tree-sub-node"/>
            </xs:sequence>
            <xs:attribute type="xs:string" name="name" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="tree-sub-node">
        <xs:complexType>
            <xs:sequence>
                <xs:element minOccurs="0" ref="actions"/>
            </xs:sequence>
            <xs:attribute type="xs:string" name="node-name" use="required"/>
            <xs:attribute type="xs:string" name="list" use="required"/>
        </xs:complexType>
    </xs:element>

    <!-- ============== Render Mode Elements =============== -->
    <xs:element name="render-mode" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element ref="text"/>
                <!-- the gwt and swing elements are just placeholders for now, won't be implemented in this version -->
                <!-- <xs:element ref="gwt"/> -->
                <!-- <xs:element ref="swing"/> -->
            </xs:choice>
        </xs:complexType>
    </xs:element>
    
    <!-- ============== Text Specific Elements =============== -->
    <xs:element name="text">
        <xs:complexType>
            <xs:simpleContent>
                <xs:extension base="xs:string">
                    <xs:attribute name="type" type="xs:string" default="any">
                        <xs:annotation><xs:documentation>
                            Can be anything. Default supported values include: text, cwiki, html, xsl-fo, xml, and csv.
                            A value of "any" will cause it to be used if no other element matches the current output type.
                        </xs:documentation></xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="location" type="xs:string">
                        <xs:annotation><xs:documentation>
                            This is the template or text file location and can be any location supported by the Resource
                            Facade including file, http, component, content, etc.
                        </xs:documentation></xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="template" type="boolean" default="true">
                        <xs:annotation><xs:documentation>
                            Interpret the text at the location as an FTL or other template?
                            Supports any template type supported by the Resource Facade.
                            Defaults to true, set to false if you want the text included literally.
                        </xs:documentation></xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="encode" default="false" type="boolean">
                        <xs:annotation><xs:documentation>
                            If true the text will be encoded so that it does not interfere with markup of the target output.
                            Templates ignore this setting and are never encoded.

                            For example, if output is HTML then data presented will be HTML encoded so that all
                            HTML-specific characters are escaped.
                        </xs:documentation></xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="no-boundary-comment" type="boolean" default="false">
                        <xs:annotation><xs:documentation>
                            Defaults to false. If true won't ever put boundary comments before this (for opening ?xml tag, etc).
                        </xs:documentation></xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>

    <!-- ============== GWT Specific Elements =============== -->
    <xs:element name="GwtWidgets" abstract="true"/>
    <xs:element name="gwt">
        <xs:complexType>
            <xs:sequence>
                <xs:element minOccurs="0" maxOccurs="unbounded" ref="GwtWidgets"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <!-- ============== Swing Specific Elements =============== -->
    <xs:element name="SwingWidgets" abstract="true"/>
    <xs:element name="swing">
        <xs:complexType>
            <xs:sequence>
                <xs:element minOccurs="0" maxOccurs="unbounded" ref="SwingWidgets"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
</xs:schema>
