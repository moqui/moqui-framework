/*
 * This software is in the public domain under CC0 1.0 Universal plus a
 * Grant of Patent License.
 *
 * To the extent possible under law, the author(s) have dedicated all
 * copyright and related and neighboring rights to this software to the
 * public domain worldwide. This software is distributed without any
 * warranty.
 *
 * You should have received a copy of the CC0 Public Domain Dedication
 * along with this software (see the LICENSE.md file). If not, see
 * <http://creativecommons.org/publicdomain/zero/1.0/>.
 */

buildscript {
    repositories { jcenter() }
    dependencies { classpath 'org.ajoberstar:grgit:2.2.1' }
}
// Not needed for explicit use, causes problems when not from git repo: plugins { id 'org.ajoberstar.grgit' version 'x.y.z' }

import org.ajoberstar.grgit.*

defaultTasks 'build'

def tomcatHome = '../apache-tomcat-8.5.14'
// no longer include version in war file name: def getWarName() { 'moqui-' + childProjects.framework.version + '.war' }
def getWarName() { 'moqui.war' }
def plusRuntimeName = 'moqui-plus-runtime.war'
def execTempDir = 'execwartmp'
def moquiRuntime = 'runtime'

def moquiConfDev = 'conf/MoquiDevConf.xml'
def moquiConfProduction = 'conf/MoquiProductionConf.xml'

def allCleanTasks = getTasksByName('clean', true)
def allBuildTasks = getTasksByName('build', true)
def allTestTasks = getTasksByName('test', true)
Set<Task> getComponentTestTasks() {
    Set<Task> testTasks = new LinkedHashSet()
    for (Project subProject in getSubprojects()) {
        if (subProject.getPath().startsWith(':runtime:component:'))
            testTasks.addAll(subProject.getTasksByName('test', false))
    }
    return testTasks
}
def getDefaultPropertyKeys() {
    def defaultProperties = []
    Node confXml = new XmlParser().parse(file('framework/src/main/resources/MoquiDefaultConf.xml'))
    for (Node defaultProperty in confXml.'default-property') {
        defaultProperties << defaultProperty.'@name'
    }
    defaultProperties
}
allTestTasks.each {
    it.systemProperties << System.properties.subMap(getDefaultPropertyKeys())
}
// ========== clean tasks ==========

task clean(type: Delete) { delete file(warName); delete file(execTempDir) }
task cleanTempDir(type: Delete) { delete file(execTempDir) }
task cleanDb { doLast {
    if (!file(moquiRuntime).exists()) return
    delete files(file(moquiRuntime+'/db/derby').listFiles()) - files(moquiRuntime+'/db/derby/derby.properties')
    delete file(moquiRuntime+'/db/h2')
    delete file(moquiRuntime+'/db/orientdb/databases')
    delete file(moquiRuntime+'/elasticsearch/data')
    delete fileTree(dir: moquiRuntime+'/txlog', include: '*')
} }
task cleanLog(type: Delete) { delete fileTree(dir: moquiRuntime+'/log', include: '*') }
task cleanSessions(type: Delete) { delete fileTree(dir: moquiRuntime+'/sessions', include: '*') }
task cleanLoadSave(type: Delete) { delete file('SaveH2.zip'); delete file('SaveDEFAULT.zip');
    delete file('SaveTransactional.zip'); delete file('SaveAnalytical.zip'); delete file('SaveOrientDb.zip'); delete file('SaveElasticSearch.zip') }
task cleanPlusRuntime(type: Delete) { delete file(plusRuntimeName) }
task cleanOther(type: Delete) { delete fileTree(dir: '.', includes: ['**/.nbattrs', '**/*~', '**/.#*', '**/.DS_Store', '**/*.rej', '**/*.orig']) }

task cleanAll { dependsOn clean, allCleanTasks, cleanDb, cleanLog, cleanSessions, cleanLoadSave, cleanPlusRuntime }

// ========== check/update tasks ==========

task getRuntime {
    description "If the runtime directory does not exist get it using settings in myaddons.xml or addons.xml; also check default components in myaddons.xml (addons.@default) and download any missing"
    doLast { checkRuntimeDirAndDefaults(project.hasProperty('locationType') ? locationType : null) }
}
task checkRuntime { doLast {
    if (!file('runtime').exists()) throw new GradleException("Required 'runtime' directory not found. Use 'gradle getRuntime' or 'gradle getComponent' or manually clone the moqui-runtime repository. This must be done in a separate Gradle run before a build so Gradle can find and run build tasks.")
} }
task gitPullAll {
    description "Do a git pull to update moqui, runtime, and each installed component (for each where a .git directory is found)"
    doLast {
        // framework and runtime
        if (file(".git").exists()) { doGitPullWithStatus(file('.').path) }
        if (file("runtime/.git").exists()) { doGitPullWithStatus(file('runtime').path) }
        // all directories under runtime/component
        for (File compDir in file('runtime/component').listFiles().findAll { it.isDirectory() && it.listFiles().find { it.name == '.git' } }) {
            doGitPullWithStatus(compDir.path)
        }
    }
}
def doGitPullWithStatus(def gitDir) {
    try {
        def curGrgit = Grgit.open(dir: gitDir)
        logger.lifecycle("\nPulling ${gitDir} (branch:${curGrgit.branch.current()?.name}, tracking:${curGrgit.branch.current()?.trackingBranch?.name})")

        def beforeHead = curGrgit.head()
        curGrgit.pull()
        def afterHead = curGrgit.head()
        if (beforeHead == afterHead) {
            logger.lifecycle("Already up-to-date.")
        } else {
            List<Commit> commits = curGrgit.log { range(beforeHead, afterHead) }
            for (Commit commit in commits) logger.lifecycle("- ${commit.getAbbreviatedId(7)} by ${commit.committer?.name}: ${commit.shortMessage}")
        }
    } catch (Throwable t) {
        logger.error(t.message)
    }
}
task gitCheckoutAll {
    description "Do a git checkout on moqui, runtime, and each installed component (for each where a .git directory is found); use -Pbranch= (required) to specify a branch, use -Pcreate=true to create branches with the given name"
    doLast {
        if (!project.hasProperty('branch')) throw new InvalidUserDataException("No branch property specified (use -Pbranch=...)")
        String curBranch = branch
        String curTag = (project.hasProperty('tag') ? tag : null) ?: curBranch
        boolean createBranch = false
        if (project.hasProperty('create') && create == 'true') createBranch = true

        List<String> gitDirectories = []
        if (file(".git").exists()) gitDirectories.add(file('.').path)
        if (file("runtime/.git").exists()) gitDirectories.add(file('runtime').path)
        for (File compDir in file('runtime/component').listFiles().findAll { it.isDirectory() && it.listFiles().find { it.name == '.git' } })
            gitDirectories.add(compDir.path)

        for (String gitDir in gitDirectories) {
            def curGrgit = Grgit.open(dir: gitDir)
            def branchList = curGrgit.branch.list(mode: org.ajoberstar.grgit.operation.BranchListOp.Mode.ALL)
            def tagList = curGrgit.tag.list()
            def targetBranch = branchList.find({ it.name == curBranch })
            def targetTag = tagList.find({ it.name == curTag })
            if (targetBranch == null && targetTag == null) {
                def originBranch = branchList.find({ it.name == 'origin/' + curBranch })
                if (originBranch != null) {
                    logger.lifecycle("In ${gitDir} branch ${curBranch} not found but found ${originBranch.name}, creating local branch tracking that branch")
                    targetBranch = curGrgit.branch.add(name: curBranch, startPoint: originBranch, mode: org.ajoberstar.grgit.operation.BranchAddOp.Mode.TRACK)
                }
            }
            if (createBranch || targetBranch != null || targetTag != null) {
                if (targetTag != null) {
                    if (createBranch && curBranch != curTag) {
                        logger.lifecycle("== Git checkout ${gitDir} tag ${curTag} and create branch ${curBranch}")
                        try { curGrgit.checkout(branch: curBranch, createBranch: true, startPoint: targetTag) }
                        catch (Exception e) { logger.lifecycle("Checkout error", e) }
                    } else {
                        logger.lifecycle("== Git checkout ${gitDir} tag ${curTag}")
                        try { curGrgit.checkout(branch: curTag, createBranch: false) }
                        catch (Exception e) { logger.lifecycle("Checkout error", e) }
                    }
                } else {
                    logger.lifecycle("== Git checkout ${gitDir} branch ${curBranch} create ${createBranch}")
                    try { curGrgit.checkout(branch: curBranch, createBranch: createBranch) }
                    catch (Exception e) { logger.lifecycle("Checkout error", e) }
                }
            } else {
                logger.lifecycle("* No branch or tag '${curBranch}' in ${gitDir}\nBranches: ${branchList.collect({it.name})}\nTags: ${tagList.collect({it.name})}")
            }
            logger.lifecycle("")
        }
    }
}
task gitStatusAll {
    description "Do a git status to check moqui, runtime, and each installed component (for each where a .git directory is found)"
    doLast {
        List<String> gitDirectories = []
        if (file(".git").exists()) gitDirectories.add(file('.').path)
        if (file("runtime/.git").exists()) gitDirectories.add(file('runtime').path)
        for (File compDir in file('runtime/component').listFiles().findAll { it.isDirectory() && it.listFiles().find { it.name == '.git' } })
            gitDirectories.add(compDir.path)
        for (String gitDir in gitDirectories) {
            def curGrgit = Grgit.open(dir: gitDir)
            logger.lifecycle("\nGit status for ${gitDir} (branch:${curGrgit.branch.current()?.name}, tracking:${curGrgit.branch.current()?.trackingBranch?.name})")

            if (curGrgit.remote.list().find({ it.name == 'upstream'})) {
                def upstreamAhead = curGrgit.log { range curGrgit.resolve.toCommit('refs/remotes/upstream/master'), curGrgit.resolve.toCommit('refs/remotes/origin/master') }
                if (upstreamAhead) logger.lifecycle("- origin/master ${upstreamAhead.size()} commits ahead of upstream/master")
            }
            def unpushed = curGrgit.log { range curGrgit.resolve.toCommit('refs/remotes/origin/master'), curGrgit.resolve.toCommit('HEAD') }
            if (unpushed) logger.lifecycle("--- ${unpushed.size()} commits unpushed (ahead of origin/master)")
            for (Commit commit in unpushed) logger.lifecycle(" - ${commit.getAbbreviatedId(8)} - ${commit.shortMessage}")
            def curStatus = curGrgit.status()
            if (curStatus.isClean()) logger.lifecycle("* nothing to commit, working directory clean")
            if (curStatus.staged.added || curStatus.staged.modified || curStatus.staged.removed) logger.lifecycle("--- Changes to be committed::")
            for (String fn in curStatus.staged.added)    logger.lifecycle("       added: ${fn}")
            for (String fn in curStatus.staged.modified) logger.lifecycle("    modified: ${fn}")
            for (String fn in curStatus.staged.removed)  logger.lifecycle("     removed: ${fn}")
            if (curStatus.unstaged.added || curStatus.unstaged.modified || curStatus.unstaged.removed) logger.lifecycle("--- Changes not staged for commit:")
            for (String fn in curStatus.unstaged.added)    logger.lifecycle("       added: ${fn}")
            for (String fn in curStatus.unstaged.modified) logger.lifecycle("    modified: ${fn}")
            for (String fn in curStatus.unstaged.removed)  logger.lifecycle("     removed: ${fn}")
        }
    }
}
task gitUpstreamAll {
    description "Do a git pull upstream:master for moqui, runtime, and each installed component (for each where a .git directory is found and has a remote called upstream)"
    doLast {
        String remoteName = project.hasProperty('remote') ? remote : 'upstream'

        List<String> gitDirectories = []
        if (file(".git").exists()) gitDirectories.add(file('.').path)
        if (file("runtime/.git").exists()) gitDirectories.add(file('runtime').path)
        for (File compDir in file('runtime/component').listFiles().findAll { it.isDirectory() && it.listFiles().find { it.name == '.git' } })
            gitDirectories.add(compDir.path)
        for (String gitDir in gitDirectories) {
            def curGrgit = Grgit.open(dir: gitDir)
            if (curGrgit.remote.list().find({ it.name == remoteName})) {
                logger.lifecycle("\nGit merge ${remoteName} for ${gitDir}")
                curGrgit.pull(remote: remoteName, branch: 'master')
            } else {
                logger.lifecycle("\nNo ${remoteName} remote for ${gitDir}")
            }

        }
    }
}

// ========== run tasks ==========

task run(type: JavaExec) {
    dependsOn checkRuntime, allBuildTasks, cleanTempDir
    workingDir = '.'; jvmArgs = ['-server', '-XX:-OmitStackTraceInFastThrow']
    systemProperties = ['moqui.conf':moquiConfDev, 'moqui.runtime':moquiRuntime]
    // NOTE: this is a hack, using -jar instead of a class name, and then the first argument is the name of the jar file
    main = '-jar'; args = [warName]
}
task runProduction(type: JavaExec) {
    dependsOn checkRuntime, allBuildTasks, cleanTempDir
    workingDir = '.'; jvmArgs = ['-server', '-Xms1024M']
    systemProperties = ['moqui.conf':moquiConfProduction, 'moqui.runtime':moquiRuntime]
    main = '-jar'; args = [warName]
}

task load(type: JavaExec) {
    description "Run Moqui to load data; to specify data types use something like: gradle load -Ptypes=seed,seed-initial,install"
    dependsOn checkRuntime, allBuildTasks
    workingDir = '.'; jvmArgs = ['-server']
    systemProperties = ['moqui.conf':moquiConfDev, 'moqui.runtime':moquiRuntime]
    main = '-jar'
    def argList = [warName, 'load']
    if (project.properties.containsKey('types')) argList.add("types=${types}")
    args = argList
}
task loadProduction(type: JavaExec) {
    dependsOn checkRuntime, allBuildTasks
    workingDir = '.'; jvmArgs = ['-server']
    systemProperties = ['moqui.conf':moquiConfProduction, 'moqui.runtime':moquiRuntime]
    main = '-jar'
    def argList = [warName, 'load']
    if (project.properties.containsKey('types')) argList.add("types=${types}")
    else argList.add("types=seed,seed-initial,install")
    args = argList
}

task saveDb { doLast {
    if (file(moquiRuntime+'/db/derby/moqui').exists())
        ant.zip(destfile: 'SaveDerby.zip') { fileset(dir: moquiRuntime+'/db/derby/moqui') { include(name: '**/*') } }
    if (file(moquiRuntime+'/db/h2').exists())
        ant.zip(destfile: 'SaveH2.zip') { fileset(dir: moquiRuntime+'/db/h2') { include(name: '**/*') } }
    if (file(moquiRuntime+'/db/orientdb/databases').exists())
        ant.zip(destfile: 'SaveOrientDb.zip') { fileset(dir: moquiRuntime+'/db/orientdb/databases') { include(name: '**/*') } }
    if (file(moquiRuntime+'/elasticsearch/data').exists())
        ant.zip(destfile: 'SaveElasticSearch.zip') { fileset(dir: moquiRuntime+'/elasticsearch/data') { include(name: '**/*') } }
} }
task loadSave {
    description "Clean all, build and load, then save database (H2, Derby), OrientDB, and ElasticSearch files; to be used before reloadSave"
    dependsOn cleanAll, load, saveDb
}

task reloadSave {
    description "After a loadSave clean database (H2, Derby), OrientDB, and ElasticSearch files and reload from saved copy"
    dependsOn cleanTempDir, cleanDb, cleanLog, cleanSessions
    dependsOn allBuildTasks
    doLast {
        if (file('SaveDerby.zip').exists()) copy { from zipTree('SaveDerby.zip'); into file(moquiRuntime+'/db/derby/moqui') }
        if (file('SaveH2.zip').exists()) copy { from zipTree('SaveH2.zip'); into file(moquiRuntime+'/db/h2') }
        if (file('SaveOrientDb.zip').exists()) copy { from zipTree('SaveOrientDb.zip'); into file(moquiRuntime+'/db/orientdb/databases') }
        if (file('SaveElasticSearch.zip').exists()) copy { from zipTree('SaveElasticSearch.zip'); into file(moquiRuntime+'/elasticsearch/data') }
    }
}

// ========== deploy tasks ==========

task deployTomcat { doLast {
    // remove runtime directory, may have been added for logs/etc
    delete file(tomcatHome + '/runtime')
    // remove ROOT directory and war to avoid conflicts
    delete file(tomcatHome + '/webapps/ROOT')
    delete file(tomcatHome + '/webapps/ROOT.war')
    // copy the war file to ROOT.war
    copy { from file(warName); into file(tomcatHome + '/webapps'); rename(warName, 'ROOT.war') }
} }

task addRuntime {
    description "Create a moqui-plus-runtime.war file with the Moqui WAR and the runtime directory embedded in it"
    dependsOn checkRuntime, allBuildTasks
    doLast {
        // make version detail files
        makeVersionDetailFiles()
        // unzip the "moqui-${version}.war" file to the wartemp directory
        //directory { dir = file('wartemp') }
        copy { from zipTree(warName); into file('wartemp') }
        // copy runtime directory (with a few exceptions) into a runtime directory in the war
        copy {
            from fileTree(dir: '.', include: moquiRuntime+'/**',
                    excludes: ['**/*.jar', '**/build', moquiRuntime+'/classes/**', moquiRuntime+'/lib/**', moquiRuntime+'/log/**', moquiRuntime+'/sessions/**'])
            into file('wartemp')
        }
        // copy the jar files from runtime/lib
        copy { from fileTree(dir: moquiRuntime+'/lib', include: '**/*.jar').files into 'wartemp/WEB-INF/lib' }
        // copy the classpath resource files from runtime/classes
        copy { from fileTree(dir: moquiRuntime+'/classes', include: '**/*') into 'wartemp/WEB-INF/classes' }
        // copy the jar files from components
        copy { from fileTree(dir: moquiRuntime+'/base-component', include: '**/*.jar').files into 'wartemp/WEB-INF/lib' }
        copy { from fileTree(dir: moquiRuntime+'/component', include: '**/*.jar').files into 'wartemp/WEB-INF/lib' }
        copy { from fileTree(dir: moquiRuntime+'/ecomponent', include: '**/*.jar').files into 'wartemp/WEB-INF/lib' }
        // add MoquiInit.properties fresh copy, just in case it was changed
        copy { from file('MoquiInit.properties') into 'wartemp/WEB-INF/classes' }
        // add Procfile to root
        copy { from file('Procfile') into 'wartemp' }
        // special case: copy elasticsearch plugin/module jars
        copy { from fileTree(dir: '.', include: moquiRuntime+'/elasticsearch/**/*.jar') into file('wartemp') }
        // special case: copy jackrabbit standalone jar (if exists)
        copy { from fileTree(dir: moquiRuntime + '/jackrabbit', include: 'jackrabbit-standalone-*.jar').files; into 'wartemp/' + moquiRuntime + '/jackrabbit' }

        // zip it up again
        ant.zip(destfile: plusRuntimeName) { fileset(dir: 'wartemp') { include(name: '**/*') } }
        // alternative once supported: zip { archiveName plusRuntimeName; from fileTree(dir: 'wartemp', include: '**/*') }
        // clean up the temporary directory
        delete file('wartemp')
        // clean up version detail files
        cleanVersionDetailFiles()
    }
}

// don't use this task directly, use addRuntimeTomcat which calls this
task deployTomcatRuntime { doLast {
    delete file(tomcatHome + '/runtime'); delete file(tomcatHome + '/webapps/ROOT'); delete file(tomcatHome + '/webapps/ROOT.war')
    copy { from file(plusRuntimeName); into file(tomcatHome + '/webapps'); rename(plusRuntimeName, 'ROOT.war') }
} }
task addRuntimeTomcat {
    dependsOn addRuntime
    dependsOn deployTomcatRuntime
}

// ========== component tasks ==========

task getDefaults {
    description "Get a component using specified location type, also check/get all components it depends on; requires component property; locationType property optional (defaults to git if there is a .git directory, otherwise to current)"
    doLast {
        String curLocationType = file('.git').exists() ? 'git' : 'current'
        if (project.hasProperty('locationType')) curLocationType = locationType
        getComponentTop(curLocationType)
    }
}
task getComponent {
    description "Get a component using specified location type, also check/get all components it depends on; requires component property; locationType property optional (defaults to git if there is a .git directory, otherwise to current)"
    doLast {
        String curLocationType = file('.git').exists() ? 'git' : 'current'
        if (project.hasProperty('locationType')) curLocationType = locationType
        getComponentTop(curLocationType)
    }
}
task getCurrent {
    description "Get the current archive for a component, also check each component it depends on and if not present get its current archive; requires component property"
    doLast { getComponentTop('current') }
}
task getRelease {
    description "Get the release archive for a component, also check each component it depends on and if not present get its configured release archive; requires component property"
    doLast { getComponentTop('release') }
}
task getBinary {
    description "Get the binary release archive for a component, also check each component it depends on and if not present get its configured release archive; requires component property"
    doLast { getComponentTop('binary') }
}
task getGit {
    description "Clone the git repository for a component, also check each component it depends on and if not present clone its git repository; requires component property"
    doLast { getComponentTop('git') }
}
task getDepends {
    description "Check/Get all dependencies for all components in runtime/component; locationType property optional (defaults to git if there is a .git directory, otherwise to current)"
    doLast {
        String curLocationType = file('.git').exists() ? 'git' : 'current'
        if (project.hasProperty('locationType')) curLocationType = locationType
        checkAllComponentDependencies(curLocationType)
    }
}

task getComponentSet {
    description "Gets all components in the specied componentSet using specified location type, also check/get all components it depends on; requires -Pcomponent property; -PlocationType property optional (defaults to git if there is a .git directory, otherwise to current)"
    doLast {
        String curLocationType = file('.git').exists() ? 'git' : 'current'
        if (project.hasProperty('locationType')) curLocationType = locationType
        if (!project.hasProperty('componentSet')) throw new InvalidUserDataException("No componentSet property specified")
        checkRuntimeDirAndDefaults(curLocationType)
        Set compsChecked = new TreeSet()
        loadComponentSet((String) componentSet, curLocationType, parseAddons(), parseMyaddons(), compsChecked)
        logger.lifecycle("Got component-set ${componentSet}, got or checked components: ${compsChecked}")
    }
}

task zipComponents {
    description "Create a .zip archive file for each component in runtime/component"
    dependsOn allBuildTasks
    doLast { for (File compDir in findComponentDirs()) createComponentZip(compDir) }
}
task zipComponent {
    description "Create a .zip archive file a single component in runtime/component; requires component property"
    dependsOn allBuildTasks
    doLast {
        if (!project.hasProperty('component')) throw new InvalidUserDataException("No component property specified")
        createComponentZip(file('runtime/component/' + component))
    }
}

// ========== utility methods ==========

def createComponentZip(File compDir) {
    File compXmlFile = file("${compDir.path}/component.xml")
    if (!compXmlFile.exists()) {
        logger.lifecycle("No component.xml file found at ${compXmlFile.path}, not creating component zip")
        return
    }
    Node compXml = new XmlParser().parse(compXmlFile)
    File zipFile = file("${compDir.parentFile.path}/${compXml.'@name'}${compXml.'@version' ? '-' + compXml.'@version' : ''}.zip")
    if (zipFile.exists()) { logger.lifecycle("Deleting existing component zip file: ${zipFile.name}"); zipFile.delete() }
    // exclude build, src, librepo, build.gradle, defaultexcludes (which includes .git)
    ant.zip(destfile: zipFile.path) { fileset(dir: compDir.parentFile.path, includes: "${compDir.name}/**", defaultexcludes: 'yes',
            excludes: "${compDir.name}/build/**,${compDir.name}/src/**,${compDir.name}/librepo/**,${compDir.name}/build.gradle") }
    logger.lifecycle("Created component zip file: ${zipFile.name}")
}

def checkRuntimeDirAndDefaults(String locType) {
    Node addons = parseAddons()
    Node myaddons = parseMyaddons()
    if (!locType) locType = file('.git').exists() ? 'git' : 'current'

    File runtimeDir = file('runtime')
    if (!runtimeDir.exists()) {
        Node runtimeNode = myaddons != null && myaddons.runtime ? (Node) myaddons.runtime[0] : null
        if (runtimeNode == null) runtimeNode = addons != null && addons.runtime ? (Node) addons.runtime[0] : null
        if (runtimeNode == null) throw new InvalidUserDataException("The runtime directory does not exist and no runtime element found in myaddons.xml or addons.xml")
        downloadComponent("runtime", locType, runtimeNode, addons, myaddons)
    }

    // look for @default in myaddons.xml only
    if (myaddons?.'@default') {
        String defaultComps = myaddons.'@default'
        Set compsChecked = new TreeSet()
        Set defaultCompsDownloaded = new TreeSet()
        for (String compName in defaultComps.split(',')) {
            compName = compName.trim()
            if (!compName) continue
            File componentDir = file("runtime/component/${compName}")
            if (componentDir.exists()) continue
            getComponent(compName, locType, addons, myaddons, compsChecked)
            defaultCompsDownloaded.add(compName)
        }
        if (defaultCompsDownloaded)
            logger.lifecycle("Got default components ${defaultCompsDownloaded}, dependent components checked: ${compsChecked}")
    }
}

def loadComponentSet(String setName, String curLocationType, Node addons, Node myaddons, Set compsChecked) {
    Node setNode = null
    if (myaddons) setNode = myaddons.'component-set'.find({ it."@name" == setName })
    if (setNode == null) setNode = addons.'component-set'.find({ it."@name" == setName })
    if (setNode == null) throw new InvalidUserDataException("Could not find component-set with name ${setName}")
    String components = setNode.'@components'
    if (components) for (String compName in components.split(","))
        getComponent(compName, curLocationType, addons, myaddons, compsChecked)
    String sets = setNode.'@sets'
    if (sets) for (String subsetName in sets.split(","))
        loadComponentSet(subsetName, curLocationType, addons, myaddons, compsChecked)
}

Collection<File> findComponentDirs() {
    file('runtime/component').listFiles().findAll({ it.isDirectory() && it.listFiles().find({ it.name == 'component.xml' }) })
}
Node parseAddons() { new XmlParser().parse(file('addons.xml')) }
Node parseMyaddons() { if (file('myaddons.xml').exists()) { new XmlParser().parse(file('myaddons.xml')) } else { null } }
Node parseComponent(project) { new XmlParser().parse(project.file('component.xml')) }

def getComponentTop(String locationType) {
    if (project.hasProperty('component')) {
        checkRuntimeDirAndDefaults(locationType)
        Set compsChecked = new TreeSet()
        File componentDir = getComponent(component, locationType, parseAddons(), parseMyaddons(), compsChecked)
        if (componentDir?.exists()) logger.lifecycle("Got component ${component}, dependent components checked: ${compsChecked}")
    } else {
        throw new InvalidUserDataException("No component property specified")
    }
}
File getComponent(String compName, String type, Node addons, Node myaddons, Set compsChecked) {
    // get the component
    Node component = myaddons != null ? (Node) myaddons.component.find({ it."@name" == compName }) : null
    if (component == null) component = (Node) addons.component.find({ it."@name" == compName })
    if (component == null) throw new InvalidUserDataException("Component ${compName} not found in myaddons.xml or addons.xml")
    if (component.'@skip-get' == 'true') { logger.lifecycle("Skipping get component ${compName} (skip-get=true)"); return null }
    File componentDir = downloadComponent("runtime/component/${compName}", type, component, addons, myaddons)

    checkComponentDependencies(compName, type, addons, myaddons, compsChecked)
    return componentDir
}
File downloadComponent(String targetDirPath, String type, Node component, Node addons, Node myaddons) {
    String compName = component.'@name'

    String repositoryName = (component.'@repository' ?: myaddons?.'@default-repository' ?: addons.'@default-repository' ?: 'github')
    Node repository = myaddons != null ? (Node) myaddons.repository.find({ it."@name" == repositoryName }) : null
    if (repository == null) repository = (Node) addons.repository.find({ it."@name" == repositoryName })
    if (repository == null) throw new InvalidUserDataException("Repository ${repositoryName} not found in myaddons.xml or addons.xml")
    Node location = (Node) repository.location.find({ it."@type" == type })
    if (location == null) throw new InvalidUserDataException("Location for type ${type} now found in repository ${repositoryName}")

    String url = Eval.me('component', component, '"""' + location.'@url' + '"""')
    logger.lifecycle("Getting ${compName} (type ${type}) from ${url} to ${targetDirPath}")

    File targetDir = file(targetDirPath)
    if (targetDir.exists()) { logger.lifecycle("Component ${compName} already exists at ${targetDir}"); return targetDir }
    if (type in ['current', 'release', 'binary']) {
        File zipFile = file("${targetDirPath}.zip")
        ant.get(src: url, dest: zipFile)
        // the eachFile closure removes the first path from each file, moving everything up a directory
        copy { from zipTree(zipFile); into targetDir; eachFile { it.setPath((it.getRelativePath().getSegments() as List).tail().join("/")); return it } }
        delete zipFile
        // delete the empty directories left over from zip expansion with first path removed
        String archiveDirName = compName + '-'
        if (type == 'current') { archiveDirName += component.'@branch' } else { archiveDirName += component.'@version' }
        // logger.lifecycle("Deleting dir ${targetDirPath}/${archiveDirName}")
        delete file("${targetDirPath}/${archiveDirName}")
    } else if (type == 'git') {
        Grgit.clone(dir: targetDir, uri: url)
    }
    logger.lifecycle("Downloaded ${compName} to ${targetDirPath}")
    return targetDir
}
def checkComponentDependencies(String compName, String type, Node addons, Node myaddons, Set compsChecked) {
    File componentDir = file("runtime/component/${compName}")
    if (!componentDir.exists()) return
    compsChecked.add(compName)
    File compXmlFile = file("${componentDir.path}/component.xml")
    if (!compXmlFile.exists()) return
    Node compXml = new XmlParser().parse(compXmlFile)
    for (Node dependsOn in compXml.'depends-on') {
        String depCompName = dependsOn.'@name'
        if (file("runtime/component/${depCompName}").exists()) {
            if (!compsChecked.contains(depCompName)) checkComponentDependencies(depCompName, type, addons, myaddons, compsChecked)
        } else {
            getComponent(depCompName, type, addons, myaddons, compsChecked)
        }
    }
}
def checkAllComponentDependencies(String type) {
    Node addons = parseAddons()
    Node myaddons = parseMyaddons()
    Set compsChecked = new TreeSet()
    for (File compDir in findComponentDirs()) {
        checkComponentDependencies(compDir.name, type, addons, myaddons, compsChecked)
    }
    logger.lifecycle("Dependent components checked: ${compsChecked}")
}

def makeVersionDetailFiles() {
    if (file(".git").exists()) {
        def topVersionMap = [framework:getVersionDetailMap(file('.'))]
        if (file("runtime/.git").exists()) topVersionMap.runtime = getVersionDetailMap(file('runtime'))
        file('runtime/version.json').write(groovy.json.JsonOutput.toJson(topVersionMap), "UTF-8")
    }
    for (File compDir in file('runtime/component').listFiles().findAll { it.isDirectory() && it.listFiles().find { it.name == '.git' } }) {
        file(compDir.path + '/version.json').write(groovy.json.JsonOutput.toJson(getVersionDetailMap(compDir)), "UTF-8")
    }
}
Map getVersionDetailMap(File gitDir) {
    def curGrgit = Grgit.open(dir: gitDir)
    String trackingName = curGrgit.branch.current()?.trackingBranch?.name
    String trackingUrl = ""
    int trackingNameSlash = trackingName ? trackingName.indexOf('/') : -1
    if (trackingNameSlash > 0) {
        String remoteName = trackingName.substring(0, trackingNameSlash)
        def trackingRemote = curGrgit.remote.list().find({ it.name == remoteName })
        if (trackingRemote != null) trackingUrl = trackingRemote.url
    }
    String headId = curGrgit.head()?.id
    // tags come in order of oldest first so want to find last in case multiple tags refer to HEAD commit
    def headTag = curGrgit.tag.list().reverse().find({ it.commit.id == headId })
    return [branch:curGrgit.branch.current()?.name, tracking:trackingName, url:trackingUrl, head:headId?.take(10), tag:headTag?.name]
}
def cleanVersionDetailFiles() {
    def runtimeVersionFile = file("runtime/version.json")
    if (runtimeVersionFile.exists()) runtimeVersionFile.delete()
    for (File compDir in file('runtime/component').listFiles().findAll { it.isDirectory() }) {
        File versionDetailFile = file(compDir.path + '/version.json')
        if (versionDetailFile.exists()) versionDetailFile.delete()
    }
}

// ========== combined tasks ==========

task cleanPullLoad { dependsOn cleanAll, gitPullAll, load }
task cleanPullTest { dependsOn cleanAll, gitPullAll, load, allTestTasks }
task cleanPullCompTest { dependsOn cleanAll, gitPullAll, load, getComponentTestTasks() }
task compTest { dependsOn getComponentTestTasks() }
